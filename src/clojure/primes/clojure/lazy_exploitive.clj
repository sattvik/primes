(ns primes.clojure.lazy-exploitive
  "Finds primes in an infinite, lazy sequence via trial by division.  This
  implementation improves on the smarter, hinted implementation by making
  direct calls to the primes collection instead of using the sequence
  abstraction."
  (:require [primes.util :as util])
  (:import clojure.lang.IPersistentCollection
           clojure.lang.IPersistentVector))

(defn divides?
  "Returns true if n is divisible by d."
  [^long n ^long d]
  (zero? (rem n d)))

(defn has-prime-factor?
  "Returns true if n has a factor in primes."
  [^long n ^IPersistentVector primes]
  (let [c     (.length primes)
        sqrtn (long (Math/sqrt n))]
    (loop [i 0]
      (when-not (= i c)
        (let [p (long (.nth primes i))]
          (cond 
            (> p sqrtn)    false
            (divides? n p) true
            :else          (recur (inc i))))))))

(defn next-prime
  "Given n and a list of prime factors, return the smallest number greater than
  or equal to n that is relatively prime to all of the numbers in known-primes."
  [^long n known-primes]
  (if (has-prime-factor? n known-primes)
    (recur (+ 2 n) known-primes)
    n))

(def prime-seq
  "A lazy sequence of prime numbers."
  (cons 2
        ((fn inner [^long p ^IPersistentCollection primes]
           (lazy-seq
             (cons p
                   (inner (next-prime (+ 2 p) primes)
                          (.cons primes p)))))
           3 [])))

(defn get-primes
  "Gets all of the primes less than n."
  [n]
  (util/get-primes prime-seq n))

(defn realise
  "Realise the first n items in prime-seq."
  [^long n]
  (util/realise prime-seq n))
