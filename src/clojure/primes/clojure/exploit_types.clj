(ns primes.clojure.exploit-types
  "Generates primes using an infinite, lazy sieve.  This version exploits
  knowing the collection type for more speed."
  (:import clojure.lang.IPersistentCollection
           clojure.lang.IPersistentVector))

(defn divides?
  "Returns true if n is divisible by d."
  [^long n ^long d]
  (zero? (rem n d)))

(defn has-prime-factor?
  "Returns true if n has a factor in primes."
  [^long n ^IPersistentVector primes]
  (let [c     (.length primes)
        sqrtn (long (Math/sqrt n))]
    (loop [i 0]
      (if (= i c)
        false
        (if (divides? n (.nth primes i))
          true
          (recur (inc i)))))))

(defn next-prime
  "Given n and a list of prime factors, return the smallest number greater than
  or equal to n that is relatively prime to all of the numbers in known-primes."
  [^long n ^IPersistentVector known-primes]
  (if (has-prime-factor? n known-primes)
    (recur (inc n) known-primes)
    n))

(def prime-seq
  ((fn next [^long n ^IPersistentCollection primes]
    (cons n (lazy-seq (next (next-prime (inc n) primes) (.cons primes n)))))
    2 []))

(deftype LazySeqPrimes [prime-set]
  primes.Primes
  (isPrime [this n]
    (contains? prime-set n)))

(defn get-primes
  "Returns a list of all the prime numbers less than n"
  [^long n]
  (LazySeqPrimes. (apply hash-set (doall (take-while #(< % n) prime-seq)))))
